;;; xdic.el ---- major mode to view dictionary
;;; $Id$

;;; Author: Tsuchiya Masatoshi <tsuchiya@pine.kuee.kyoto-u.ac.jp>
;;; Keywords: dictionary

;;; Commentary:

;; 英和辞書を閲覧する目的で作成した major mode です。
;; 利用及び再配布の際は、GNU 一般公用許諾書の適当なバージョンにしたがっ
;; て下さい。

;; 一次配布元
;;    http://www-nagao.kuee.kyoto-u.ac.jp/member/tsuchiya/elisp/xdic.html


;;; ※※※ 注意 ※※※

;; このプログラムは、まだ作成されたばかりですので、これから多数の変更
;; が出ると思われます。注意して使ってください。
;;
;; また、こんな機能が欲しいとか、動作が希望と違うなど、要望があれば遠
;; 慮なく連絡してください。出来るだけ対応したいと思います。


;;; How to Install

;;	(1) xdic.el と stem.el を適当な場所に保存して下さい。必要なら
;;	    バイトコンパイルして下さい。
;;	(2) 辞書を検索するために look を呼び出しています。パスが通って
;;	    いるか確認して下さい。
;;	(3) 辞書を変換して、適当な場所に保存して下さい。
;;	    xdic.el は、辞書のそれぞれのレコードが1つの見出し語と1つの
;;	    説明文からなり、かつ見出し語と説明文がタブで区切られている
;;	    ことを要求します。
;;	(4) .emacs に次のようなコードを挿入します。
;;
;;		(autoload 'xdic:describe-word "xdic" "英単語の意味を調べる" t nil)
;;		(global-set-key "\C-cw" 'xdic:describe-word)
;;
;;	    好みに合わせて適当にキーバインドは変更して下さい。

;; Emacs20 で使う場合は、
;;
;;		(set-language-environment "Japanese")
;;		(set-terminal-coding-system 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。

(provide 'xdic)


;;;----------------------------------------------------------------------
;;;		カスタマイズ用変数
;;;----------------------------------------------------------------------

(defvar xdic:eiwa-dictionary
  (let ((s (make-symbol "eiwa")))
    (put s 'filename (expand-file-name "~/usr/lib/elisp/gene.dic"))
    (put s 'search-function 'xdic:look)
    s)
  "*英和辞書の属性リスト")

(defvar xdic:waei-dictionary
  (let ((s (make-symbol "waei")))
    (put s 'filename (expand-file-name "~/usr/lib/elisp/jgene.dic"))
    (put s 'search-function 'xdic:grep)
    s)
  "*和英辞書の属性リスト")

;;; 検索結果の表示を調整する変数
(defvar xdic:left-margin 2 "説明文の left margin")
(defvar xdic:fill-column default-fill-column "説明文の fill column")
(defvar xdic:window-height 10 "検索結果表示ウインドウの高さ")
(defvar xdic:disable-select-window nil
  "検索結果表示ウインドウに常にカーソルを移動する場合に nil を設定する")
(defvar xdic:left-margin-ignored-by-fill-region (string-match "19\\.28" emacs-version)
  "fill-region 関数が left-margin の設定を無視する場合は nil 以外を設定する")
(defvar xdic:face-style 'bold  "見出し語の face の style")
(defvar xdic:face-color "black" "見出し語の face の color")

;;; キーバインドを調節する変数
(defvar xdic:disable-vi-key nil
  "辞書閲覧に vi ライクのキーを使わない場合は nil 以外を設定する")

(defconst xdic:version "1.7")

(defconst xdic:buffer-name "*xdic*" "検索結果表示バッファの名前")
(defconst xdic:mode-name "Xdic" "検索結果を表示するバッファの major mode")



;;;----------------------------------------------------------------------
;;;		初期化
;;;----------------------------------------------------------------------

;;; -tion, -ize などの語尾変化を処理するためのライブラリをロード
(require 'stem)


;;; Emacs19.28 ベースの Mule2.3 では previous-overlay-change が未定義
;;; なので代替関数を定義する
(or (fboundp 'previous-overlay-change)
    (defun previous-overlay-change (pos) "\
Return the previous position before POS where an overlay starts or ends.
If there are no more overlay boundaries before POS, return (point-min)."
      (if (> pos (point-max))
	  (error "Specified position is larger than point-max"))
      (save-excursion
	(let (next (prev (point-min)))
	  (while (> pos (setq next (next-overlay-change prev)))
	    (setq prev next))
	  prev))))




;;;----------------------------------------------------------------------
;;;		look を実行する関数
;;;----------------------------------------------------------------------

(defvar xdic:look-command-name "look" "*Executable file name of look")

(defvar xdic:look-option "-f" "*Command line option for look")

(defvar xdic:look-coding-system (if (>= emacs-major-version 20) 'euc-japan *euc-japan*)
  "*Coding system for look")

(defun xdic:look (dictionary string &optional search-method) "\
look を利用して辞書を検索した結果をカレントバッファに書き込む関数
search-method の値によって次のように動作を変更する。
    nil    : 前方一致検索
    t      : 後方一致検索
    lambda : 完全一致検索
"
  (if (eq t search-method) (error "%s" "後方一致検索は使えません"))
  (or (get 'xdic:look 'setup)
      (progn
	(if (>= emacs-major-version 20)
	    (setq process-coding-system-alist (cons (cons (format ".*%s" xdic:look-command-name)
							  xdic:look-coding-system)
						    (if (boundp 'process-coding-system-alist)
							process-coding-system-alist)))
	  (define-program-coding-system nil (format ".*%s" xdic:look-command-name) xdic:look-coding-system))
	(put 'xdic:look 'setup t)))
  (let ((buf (get dictionary 'search-buffer)))
    (save-excursion
      (set-buffer (if (and (bufferp buf) (buffer-name buf)) buf
		    (setq buf (put dictionary 'search-buffer (generate-new-buffer "*xdic-look*")))))
      (erase-buffer)
      (call-process xdic:look-command-name nil t nil xdic:look-option string (get dictionary 'filename))
      (if (eq search-method 'lambda)
	  ;; 完全一致検索の場合は余分な検索結果を削除する
	  (progn
	    (goto-char (point-min))
	    (while (if (looking-at (format "%s\t" (regexp-quote string)))
		       (= 0 (forward-line 1))
		     (delete-region (point) (point-max)))))))
    (insert-buffer-substring buf)))




;;;----------------------------------------------------------------------
;;;		grep を実行する関数
;;;----------------------------------------------------------------------

(defvar xdic:grep-command-name "egrep" "*Executable file name of grep")

(defvar xdic:grep-option "-i" "*Command line option for grep")

(defvar xdic:grep-coding-system (if (>= emacs-major-version 20) 'euc-japan *euc-japan*)
  "*Coding system for grep")

(defun xdic:grep (dictionary string &optional search-method) "\
grep を利用して辞書を検索した結果をカレントバッファに書き込む関数
search-method の値によって次のように動作を変更する。
    nil    : 前方一致検索
    t      : 後方一致検索
    lambda : 完全一致検索
"
  (or (get 'xdic:grep 'setup)
      (progn
	(if (>= emacs-major-version 20)
	    (setq process-coding-system-alist (cons (cons (format ".*%s" xdic:grep-command-name)
							  xdic:grep-coding-system)
						    (if (boundp 'process-coding-system-alist)
							process-coding-system-alist)))
	  (define-program-coding-system nil (format ".*%s" xdic:grep-command-name) xdic:grep-coding-system))
	(put 'xdic:grep 'setup t)))
  (let ((buf (get dictionary 'search-buffer)))
    (save-excursion
      (set-buffer (if (and (bufferp buf) (buffer-name buf)) buf
		    (setq buf (put dictionary 'search-buffer (generate-new-buffer "*xdic-grep*")))))
      (erase-buffer)
      (call-process xdic:grep-command-name nil t nil xdic:grep-option
		    (cond
		     ((eq search-method nil)
		      (format "^%s" string))
		     ((eq search-method t)
		      (format "^[^\t]*%s\t" string))
		     (t ;; (eq search-method 'lambda)
		      (format "^%s\t" string)))
		    (get dictionary 'filename)))
    (insert-buffer-substring buf)))




;;;----------------------------------------------------------------------
;;;		英和辞書を検索する関数
;;;----------------------------------------------------------------------

(defun xdic:search-english-word (word)
  (cond
   ;; 検索語の末尾に * がある場合 -> 前方一致検索
   ((string= "*" (substring word -1))
    (funcall (get xdic:eiwa-dictionary 'search-function) xdic:eiwa-dictionary (substring word 0 -1)))
   ;; 検索語の先頭に * がある場合 -> 後方一致検索
   ((string= "*" (substring word 0 1))
    (funcall (get xdic:eiwa-dictionary 'search-function) xdic:eiwa-dictionary (substring word 1) t))
   ;; それ以外 -> stemming して検索
   (t
    (let ((wlist (stem:stripping-suffix word))
	  (case-fold-search t))		; 大文字/小文字を区別しない
      (funcall (get xdic:eiwa-dictionary 'search-function) xdic:eiwa-dictionary (car wlist))
      (catch 'loop
	(mapcar '(lambda (s)
		   (setq s (regexp-quote s))
		   (if (re-search-backward (format "^%s\t" s) nil t)
		       ;; 原形を見つけた場合
		       (progn
			 (while (re-search-backward (format "^%s\t" s) nil t))
			 (delete-region (point-min) (point))
			 (while (if (looking-at (format "%s[^\t]*\t" s))
				    (= 0 (forward-line 1))
				  (delete-region (point) (point-max))))
			 (throw 'loop t))))
		(reverse wlist))
	(setq word (format "%s / %s" (car wlist) word)))
      ))))




;;;----------------------------------------------------------------------
;;;		和英辞書を検索する関数
;;;----------------------------------------------------------------------

(defun xdic:search-japanese-word (word)
  (cond
   ;; 検索語の末尾に * がある場合 -> 前方一致検索
   ((string= "*" (substring word -1))
    (funcall (get xdic:waei-dictionary 'search-function) xdic:waei-dictionary (substring word 0 -1)))
   ;; 検索語の先頭に * がある場合 -> 後方一致検索
   ((string= "*" (substring word 0 1))
    (funcall (get xdic:waei-dictionary 'search-function) xdic:waei-dictionary (substring word 1) t))
   ;; それ以外 -> 前方一致検索
   (t
    (funcall (get xdic:waei-dictionary 'search-function) xdic:waei-dictionary word))))




;;;----------------------------------------------------------------------
;;;		本体
;;;----------------------------------------------------------------------

(defun xdic:word-at-point () "\
カーソル位置の英単語を返す関数"
  (save-excursion
    (if (not (looking-at "\\<"))
        (forward-word -1))
    (if (looking-at "[A-Za-z]+")
	(downcase (buffer-substring (match-beginning 0) (match-end 0))))))



(defvar xdic:read-minibuffer-history '() "\
xdic:read-from-minibuffer 関数のヒストリ")
(defun xdic:read-from-minibuffer (&optional prompt init) "\
ミニバッファから英単語を読みとる関数"
  (or init (setq init (or (xdic:word-at-point) "")))
  (setq xdic:read-minibuffer-history
	(cons init xdic:read-minibuffer-history))
  (downcase
   (read-from-minibuffer (or prompt "Input word : ") init
			 nil nil '(xdic:read-minibuffer-history . 1))))



(defun xdic:fill-region (start end) "\
fill-region の wrapper
Emacs のバージョンによって異なっている fill-region の動作の違い
を吸収するための wrapper"
  (save-match-data
    (if xdic:left-margin-ignored-by-fill-region
	;; Emacs-19.28 附属の fill-region は、left-margin を無視するので強制的に indent する
	(let ((fill-column (- fill-column xdic:left-margin)))
	  (fill-region start end)
	  (indent-region start (point) xdic:left-margin))
      (fill-region start end))
    (save-excursion			; 余分な空行を削除する
      (beginning-of-line)
      (if (looking-at "^[ \t]*$")
	  (delete-region (1- (point)) (match-end 0)))
      )))



;;; 単語を辞書で調べる関数
(defun xdic:describe-word (word)
  "Display the meaning of word."
  (interactive (list (xdic:read-from-minibuffer)))
  (if (< (length word) 2)
      (setq word (xdic:read-from-minibuffer
		  (format "\"%s\" is too short word. Input word again : " word)
		  word)))
  (set-buffer (get-buffer-create xdic:buffer-name))
  (or (string= mode-name xdic:mode-name) (xdic-mode))
  (setq buffer-read-only nil)
  (erase-buffer)
  (if (string-match "\\cj" word)
      (xdic:search-japanese-word word)
    (xdic:search-english-word word))
  (if (= 0 (buffer-size))
      (message "Can't find word : %s" word)
    (goto-char (point-min))
    (while (progn
	     (overlay-put (make-overlay (point)
					(progn (skip-chars-forward "^\t") (point)))
			  'face 'xdic:face) ; 見出し語を修飾する
	     (delete-char 1)		; 区切りのタブを取り除く
	     (insert "\n")
	     (xdic:fill-region (point) (progn (end-of-line) (point)))
	     (goto-char (1+ (point)))
	     (not (eobp))))
    (setq buffer-read-only t)
    (set-buffer-modified-p nil)
    (goto-char (point-min))
    (xdic:display-buffer)))



(defun xdic:describe-word-at-point ()
  "Display the meaning of word at point in Japanese."
  (interactive)
  (xdic:describe-word (or (xdic:word-at-point)
			  (xdic:read-from-minibuffer))))



;;; 次の項目に移動する関数
(defun xdic:forward-item ()
  "Move point to the next item."
  (interactive)
  (let ((o))
    (goto-char (next-overlay-change
		(if (setq o (car (overlays-at (point))))
		    (overlay-end o)
		  (point))))))



;;; 前の項目に移動する関数
(defun xdic:backward-item ()
  "Move point to the previous item."
  (interactive)
  (let ((o))
    (goto-char (previous-overlay-change
		(previous-overlay-change
		 (if (setq o (car (overlays-at (point))))
		     (overlay-start o)
		   (previous-overlay-change (previous-overlay-change (point)))))))))



(defun xdic:goto-point-min () "\
バッファの先頭に移動する関数"
  (interactive)
  (goto-char (point-min)))



(defun xdic:goto-point-max () "\
バッファの末尾に移動する関数"
  (interactive)
  (goto-char (point-max)))



(defun xdic:display-buffer () "\
検索結果表示バッファを表示する関数"
  (interactive)
  (let ((w1 (selected-window))
	(w2 (get-buffer-window xdic:buffer-name)))
    (if w2 (select-window w2)
      (setq w2 (select-window (if (one-window-p)
				  (split-window w1 (- (window-height) xdic:window-height))
				(next-window))))
      (set-window-buffer w2 xdic:buffer-name))
    (recenter 0)
    (if xdic:disable-select-window (select-window w1))))



(defun xdic:other-window () "\
検索表示バッファから元のバッファに戻る関数"
  (interactive)
  (let ((w (selected-window)))
    (if (and (string= (buffer-name (window-buffer w))
		      xdic:buffer-name)
	     (one-window-p))
	(progn
	  (split-window w (- (window-height) xdic:window-height))
	  (set-window-buffer w (other-buffer)))
      (other-window -1))))



(defun xdic:close-window () "\
検索表示バッファを表示しているウインドウを消去する関数"
  (interactive)
  (let ((w (get-buffer-window xdic:buffer-name)))
    (if w
	(cond
	 ((= (window-height w) xdic:window-height)
	  (delete-window w))
	 (t
	  (set-window-buffer w (other-buffer))
	  (select-window (next-window)))
	 ))))



(defun xdic:kill-window () "\
検索結果表示バッファを削除する関数"
  (interactive)
  (xdic:close-window)
  (kill-buffer xdic:buffer-name))



;;; 辞書を閲覧する major-mode
(defun xdic-mode () "\
辞書を閲覧するメジャーモード

\\{xdic-mode-map}
"
  (kill-all-local-variables)
  (make-local-variable 'fill-column)
  (setq major-mode 'xdic-mode
	mode-name   xdic:mode-name
	fill-column xdic:fill-column
	left-margin xdic:left-margin
	xdic-mode-map (make-keymap))
  ;; キーバインドの設定
  (define-key xdic-mode-map " " 'scroll-up)
  (define-key xdic-mode-map "b" 'scroll-down)
  (define-key xdic-mode-map [backspace] 'scroll-down)
  (define-key xdic-mode-map [delete] 'scroll-down)
  (define-key xdic-mode-map "\C-?" 'scroll-down)
  (define-key xdic-mode-map "n" 'xdic:forward-item)
  (define-key xdic-mode-map "\t" 'xdic:forward-item)
  (define-key xdic-mode-map "p" 'xdic:backward-item)
  (define-key xdic-mode-map "\M-\t" 'xdic:backward-item)
  (define-key xdic-mode-map "o" 'xdic:other-window)
  (define-key xdic-mode-map "q" 'xdic:close-window)
  (define-key xdic-mode-map "Q" 'xdic:kill-window)
  (define-key xdic-mode-map "w" 'xdic:describe-word)
  (define-key xdic-mode-map "<" 'xdic:goto-point-min)
  (define-key xdic-mode-map ">" 'xdic:goto-point-max)
  (define-key xdic-mode-map "?" 'describe-mode)
  (cond
   ((not xdic:disable-vi-key)
    (define-key xdic-mode-map "h" 'backward-char)
    (define-key xdic-mode-map "j" 'next-line)
    (define-key xdic-mode-map "k" 'previous-line)
    (define-key xdic-mode-map "l" 'forward-char)))
  (use-local-map xdic-mode-map)
  ;; 見出し語の face の設定
  (make-face 'xdic:face)
  (and (or (not (fboundp 'facep))
	   (facep xdic:face-style))
       (copy-face xdic:face-style 'xdic:face))
  (and window-system
       xdic:face-color
       (set-face-foreground 'xdic:face xdic:face-color))
  (run-hooks 'xdic-mode-hook))
