;;; xdic.el ---- major mode to view dictionary
;;; $Id$

;;; Author: Tsuchiya Masatoshi <tsuchiya@pine.kuee.kyoto-u.ac.jp>
;;; Keywords: dictionary

;;; Commentary:

;; 英和/和英辞書を閲覧する目的で作成した major mode です。
;; 利用及び再配布の際は、GNU 一般公用許諾書の適当なバージョンにしたがっ
;; て下さい。

;; 一次配布元
;;    http://www-nagao.kuee.kyoto-u.ac.jp/member/tsuchiya/elisp/xdic.html


;;; ※※※ 注意 ※※※

;; このプログラムは、まだ作成されたばかりですので、これから多数の変更
;; が出ると思われます。注意して使ってください。
;;
;; また、こんな機能が欲しいとか、動作が希望と違うなど、要望があれば遠
;; 慮なく連絡してください。出来るだけ対応したいと思います。


;;; Install:

;; (1) xdic.el, xdic-sgml.el, xdic-grep.el, xdic-array.el,
;;     xdic-compat.el と stem.el を適当な場所に保存して、必要ならバイ
;;     トコンパイルして下さい。
;;
;;
;; (2) xdic-sgml.el, xdic-grep.el, xdic-array.el, xdic-compat.el は辞
;;     書を検索するためのライブラリです。これらのライブラリのどれかを
;;     使って辞書を検索できるようにして下さい。詳細については、README 
;;     とそれぞれのソースファイルを参照。
;;
;;
;; (3) 使えるようにした辞書のリストを、xdic-eiwa-dictionary-list およ
;;     び xdic-waei-dictionary-list に設定します。例えば、英和辞書
;;     /usr/dict/gene.dic を xdic-grep.el を使って検索する場合は次のよ
;;     うになります。
;;
;;         (setq xdic-eiwa-dictionary-list '((xdic-grep "/usr/dict/gene.dic")))
;;
;;     複数の辞書を同時に検索することも出来ます。
;;
;;         (setq xdic-waei-dictionary-list '((xdic-array "~/data/edict")
;;                                           (xdic-comat "/usr/dict/jgene.dic")))
;;
;;     辞書を利用しない場合は nil を代入して下さい。また、これらの設定
;;     は ~/.emacs などの適切な場所に書き込んで下さい。
;;
;;
;; (4) ~/.emacs に次のようなコードを挿入します。
;;
;;         (autoload 'xdic-describe-word "xdic" "英単語の意味を調べる" t nil)
;;         (global-set-key "\C-cw" 'xdic-describe-word)
;;
;;     好みに合わせて適当にキーバインドは変更して下さい。


;;; Note:

;; 検索結果の表示の仕方や動作を制御する変数があります。詳細については、
;; 下の source を参照して下さい。
;;
;; grep / array などの外部コマンドを利用して辞書検索する場合は、それら
;; の外部コマンドが対応している漢字コードを設定して、辞書もその漢字コー
;; ドに合わせる必要があります。その場合、日本語 EUC がおそらく一番安全
;; でしょう。
;;
;; Emacs20 で使う場合は、
;;
;;     (set-language-environment "Japanese")
;;     (set-terminal-coding-system 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。
;;
;; XEmacs で使う場合は、
;;
;;     (set-language-environment "Japanese")
;;     (set-default-coding-systems 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。


(provide 'xdic)
(require 'xdic-sgml)
(require 'xdic-grep)
(require 'stem)
  

;;;----------------------------------------------------------------------
;;;		カスタマイズ用変数
;;;----------------------------------------------------------------------

(defvar xdic-eiwa-dictionary-list
  (list (list (if xdic-grep-command 'xdic-grep 'xdic-gene) "~/usr/dict/gene.dic")) "\
*Options of an English-Japanese dictionary.
英和辞典の検索メソッドを指定する変数")

(defvar xdic-waei-dictionary-list
  (list (list (if xdic-grep-command 'xdic-grep 'xdic-gene) "~/usr/dict/edict.dic")) "\
*Options of an English-Japanese dictionary.
和英辞典の検索メソッドを指定する変数")

(defvar xdic-default-coding-system
  (if (>= emacs-major-version 20)
      (if (string-match "XEmacs" emacs-version)
	  (cond
	   ((member 'euc-japan-unix (coding-system-list)) 'euc-japan-unix)
	   ((member 'euc-jp-unix (coding-system-list)) 'euc-jp-unix)
	   (t 'euc-japan))
	'euc-japan-unix)
    *euc-japan*unix)
  "*Default coding-system for xdic and libraries.")

(defvar xdic-left-margin 2 "*Left margin of contents.
説明文の左側の余白幅")

(defvar xdic-fill-column default-fill-column "*Right edge of contents.
説明文を整形する幅")

(defvar xdic-window-height 10 "*Height of window to show entrys and contents.
検索結果表示ウインドウの高さ")

(defvar xdic-disable-select-window nil "*Option to disable to select other window.
検索結果表示ウインドウにカーソルを移動しないようにする場合は nil 以外を設定する")

(defvar xdic-face-style 'bold  "*Style of entry.
見出し語を表示するために使う装飾形式")

(defvar xdic-face-color "black" "*Color of entry.
見出し語を表示するために使う色")

(defvar xdic-disable-vi-key nil "*Option to disable some key.
辞書閲覧に vi ライクのキーを使わない場合は nil 以外を設定する")




;;;----------------------------------------------------------------------
;;;		内部変数
;;;----------------------------------------------------------------------

(defvar xdic-english-prep-list '("at" "by" "for" "in" "on" "of" "with" "as" "before" "after") "\
List of English prepositions
英語の前置詞のリスト")

(defvar xdic-english-prep-regexp
  (format "\\(%s\\)\\b" (mapconcat 'regexp-quote xdic-english-prep-list "\\|")) "\
Regexp of Englist prepositions
英語の前置詞とマッチする正規表現")

(defvar xdic-eiwa-symbol-list nil "英和辞典のシンボル")
(defvar xdic-waei-symbol-list nil "和英辞典のシンボル")
(defvar xdic-buffer-start-point nil "検索結果表示バッファの表示開始ポイント")
(defvar xdic-mode-map nil "Keymap of xdic-mode")
(defconst xdic-version "2.0beta4")
(defconst xdic-buffer-name "*xdic*" "検索結果表示バッファの名前")
(defconst xdic-mode-name "Xdic" "検索結果を表示するバッファの major mode")




;;;----------------------------------------------------------------------
;;;		検索メソッドを呼び出す関数
;;;----------------------------------------------------------------------

(defun xdic-init-dictionary (option-list) "\
Function to initialize dictionary.
指定された辞書と関連付けられている検索ライブラリを初期化する関数"
  (let (dic)
    (and option-list
	 (listp option-list)
	 (require (car option-list))
	 (setq dic (apply (get (car option-list) 'init-dictionary) (cdr option-list)))
	 (xdic-dictionary-symbol-p dic)
	 (put dic 'search-method (car option-list))
	 dic)))


(defun xdic-open-dictionary (dic) "\
Function to open dictionary.
指定された辞書を検索できるようにする関数"
  (and (xdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'open-dictionary) dic)))


(defun xdic-close-dictionary (dic) "\
Function to close dictionary.
指定された辞書と関連付けられている検索ライブラリを終了する関数"
  (and (xdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'close-dictionary) dic)))


(defun xdic-search-entry (dic word &optional search-type) "\
Function to search word in dictionary.
指定された辞書を検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (mapcar (function
	   (lambda (c)
	     (list (car c) dic (cdr c))))
	  (funcall (get (get dic 'search-method) 'search-entry) dic word search-type)))


(defun xdic-sort-dictionary-order (entry-list) "\
Function to sort entry list in dictionary order.
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列 
ENTRY-LIST を、見出し語の辞書順に並べ替える関数。"
  (mapcar 'cdr
	  (sort (mapcar (function
			 (lambda (entry)
			   (if (string-match "\\Ca" (car entry))
			       (cons (concat (car entry) "\^@") entry)
			     (cons (concat (mapconcat 'downcase
						      (xdic-split-string (car entry) "[^A-z0-9]+")
						      " ")
					   "\^@" (car entry) "\^@")
				   entry))))
			entry-list)
		(function (lambda (a b) (string< (car a) (car b)))))))


(defun xdic-search-multi-dictionaries (dic-list word &optional search-type) "\
Function to search word in multi dictionaries.
指定されている複数の辞書を串刺検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (xdic-sort-dictionary-order
   (apply 'append
	  (mapcar (function
		   (lambda (dic)
		     (xdic-search-entry dic word search-type)))
		  dic-list))))


(defun xdic-get-content (dic id) "\
Function to get content.
指定されている辞書から定義文を読み出す関数"
  (funcall (get (get dic 'search-method) 'get-content) dic id))


(defun xdic-buffer-live-p (buffer)
  (and (bufferp buffer) (buffer-name buffer) buffer))


(defun xdic-make-dictionary-symbol ()
  (make-symbol "xdic-dictionary"))


(defun xdic-dictionary-symbol-p (symbol)
  (equal (symbol-name symbol) "xdic-dictionary"))




;;;----------------------------------------------------------------------
;;;		内部関数
;;;----------------------------------------------------------------------

(defun xdic-insert-content (word content)
  "見出し語と定義文を整形しながら挿入する関数"
  (xdic-overlay-put (xdic-make-overlay (point) (progn (insert word) (point))) 'face 'xdic-face)
  (insert "\n")
  (save-restriction
    (narrow-to-region (point) (progn (insert content) (point)))
    (goto-char (point-min))
    (while (re-search-forward ",[^ ]" nil t)
      (goto-char (1+ (match-beginning 0)))
      (insert " ")
      (goto-char (match-end 0)))
    (goto-char (point-min))
    (while (re-search-forward "[^ 0-9]\\(/\\)[^ 0-9]" nil t)
      (goto-char (match-beginning 1))
      (insert " ")
      (goto-char (1+ (point)))
      (insert " ")
      (goto-char (match-end 0)))
    (xdic-fill-region (point-min) (goto-char (point-max))))
  (insert "\n"))


;; 検索形式を判別するマクロ
(put 'xdic-decide-query-type 'lisp-indent-function 2)
(defmacro xdic-decide-query-type (dic-list query &rest sexp) "\
QUERY から検索形式を判定して複数の辞書 DIC-LIST を検索するマクロ

QUERY に検索形式を指定する構造が含まれていない場合は、default の動作と
して SEXP を評価する。通常の検索の場合は、検索された見出し語のリストを
返す。"
  (` (cond
      ;; 検索語が '' で囲まれている場合 -> 完全一致検索
      ((and (equal ?' (string-to-char (, query)))
	    (equal "'" (substring (, query) -1)))
       (mapcar (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1 -1) 'lambda)))
      ;; 検索語が // で囲まれている場合 -> 任意検索
      ((and (equal ?/ (string-to-char (, query)))
	    (equal "/" (substring (, query) -1)))
       (mapcar (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1 -1) 0)))
      ;; 検索語の先頭に * がある場合 -> 後方一致検索
      ((equal ?* (string-to-char (, query)))
       (mapcar (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1) t)))
      ;; 検索語の末尾に * がある場合 -> 前方一致検索
      ((equal "*" (substring (, query) -1))
       (mapcar (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 0 -1))))
      ;; 特に指定がない場合 -> 指定された S 式を評価
      (t
       (,@ sexp)))))


;; 英和辞典を検索する関数
(defun xdic-search-eiwa-dictionary (query)
  (xdic-decide-query-type xdic-eiwa-symbol-list query
    (let (word-list stem-list orig pat point str)
      (setq word-list (xdic-split-string (downcase query)))
      (prog1 (mapcar
	      (function
	       (lambda (entry)
		 (and (not point)
		      (string-match pat (car entry))
		      (setq point (point)))
		 (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		 (car entry)))
	      (prog1 (or
		      ;; (1) 不規則変化動詞を検索する
		      (and
		       (setq stem-list (copy-sequence (assoc (car word-list) stem:irregular-verb-alist)))
		       (xdic-sort-dictionary-order
			(apply 'append
			       (mapcar
				(function
				 (lambda (word)
				   (setq pat (format "^\\(%s$\\|%s \\)"
						     (regexp-quote word) (regexp-quote word)))
				   (delq nil
					 (mapcar
					  (function
					   (lambda (entry)
					     (and (string-match pat (car entry))
						  (or orig (setq orig word))
						  entry)))
					  (apply 'append
						 (mapcar
						  (function
						   (lambda (dic)
						     (xdic-search-entry dic word)))
						  xdic-eiwa-symbol-list))))))
				stem-list))))
		      ;; (2) 不規則変化動詞を無視した stemming を行なって検索する
		      (progn
			(setq stem-list (let ((stem:irregular-verb-alist nil))
					  (stem:stripping-suffix (car word-list))))
			;; 最長部分列を求める
			(setq pat (let* ((w1 (car stem-list))
					 (w2 (car (reverse stem-list)))
					 (i (min (length w1) (length w2))))
				    (while (not (string= (substring w1 0 i)
							 (substring w2 0 i)))
				      (setq i (1- i)))
				    (substring w1 0 i)))
			(delq nil (mapcar
				   (function
				    (lambda (entry)
				      (if (string-match pat (car entry)) entry)))
				   (prog1 (mapcar
					   (function
					    (lambda (entry)
					      ;; 検索結果から原形と推定される見出し語を検索
					      (setq str (downcase (car entry)))
					      (and (member str stem-list)
						   (not (member str orig))
						   (setq orig (cons str orig)))
					      entry))
					   (xdic-search-multi-dictionaries xdic-eiwa-symbol-list pat))
				     (if orig
					 (setq stem-list (copy-sequence orig)
					       orig (if (member (car word-list) orig)
							(car word-list)
						      (car (sort orig (function
								       (lambda (a b) (> (length a) (length b)))))))
					       pat (format "^\\(%s\\)"
							   (mapconcat (function
								       (lambda (w)
									 (format "%s$\\|%s "
										 (regexp-quote w)
										 (regexp-quote w))))
								      stem-list "\\|")))
				       (setq orig pat
					     pat (concat "^" (regexp-quote pat)))
				       (message "Can't find original form of \"%s\""
						(car word-list))
				       ))))))
		(setq pat (if (nth 1 word-list)
			      (concat "^\\("
				      (mapconcat (function
						  (lambda (w)
						    (format "%s +%s$\\|%s +%s "
							    (regexp-quote w)
							    (regexp-quote (nth 1 word-list))
							    (regexp-quote w)
							    (regexp-quote (nth 1 word-list)))))
						 stem-list "\\|")
				      (if (string= orig (car word-list))
					  "\\)"
					(format "\\|%s\\)" (regexp-quote orig))))
			    (format "^%s$" (regexp-quote orig))))))
	(if point (setq xdic-buffer-start-point point))))))


;; 和英辞典を検索する関数
(defun xdic-search-waei-dictionary (query)
  (xdic-decide-query-type xdic-waei-symbol-list query
    ;; 特に指定がない場合 -> 前方一致検索
    (mapcar (function
	     (lambda (entry)
	       (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
	       (car entry)))
	    (xdic-search-multi-dictionaries xdic-waei-symbol-list query))))




;;;----------------------------------------------------------------------
;;;		本体
;;;----------------------------------------------------------------------

(defun xdic-word-at-point () "\
カーソル位置の単語を返す関数"
  (save-excursion
    (if (not (looking-at "\\<")) (forward-word -1))
    (downcase
     (if (looking-at xdic-english-prep-regexp)
	 (buffer-substring (progn (forward-word -1) (point)) (progn (forward-word 2) (point)))
       (buffer-substring (point) (progn (forward-word 1) (point)))))))


(defvar xdic-read-minibuffer-history '() "\
xdic-read-from-minibuffer 関数のヒストリ")
(defun xdic-read-from-minibuffer (&optional prompt init) "\
ミニバッファから単語を読みとる関数"
  (or init (setq init (or (xdic-word-at-point) "")))
  (setq xdic-read-minibuffer-history
	(cons init xdic-read-minibuffer-history))
  (downcase (read-from-minibuffer (or prompt "Input word : ") init
				  nil nil '(xdic-read-minibuffer-history . 1))))


(defun xdic-select-search-function ()
  "検索関数を選ぶ"
  (message "辞書を選んで下さい: E)英和 J)和英")
  (let ((sw (selected-window))
	(c (read-char)))
    (select-window sw)
    (cond
     ((= c ?e) 'xdic-search-eiwa-dictionary)
     ((= c ?j) 'xdic-search-waei-dictionary)
     (t (xdic-select-search-function)))))


;; 単語を辞書で調べる関数
(defun xdic-describe-word (word &optional search-function)
  "Display the meaning of word."
  (interactive
   (list (xdic-read-from-minibuffer)
	 (if current-prefix-arg (xdic-select-search-function))))
  (and (interactive-p)
       (< (length word) 2)
       (setq word (xdic-read-from-minibuffer
		   (format "\"%s\" is too short word. Input word again : " word)
		   word)))
  (set-buffer (get-buffer-create xdic-buffer-name))
  (or (string= mode-name xdic-mode-name) (xdic-mode))
  (setq buffer-read-only nil)
  (erase-buffer)
  (let ((case-fold-search t)
	(xdic-buffer-start-point (point-min)))
    (if (prog1 (funcall (or search-function
			    (if (string-match "\\cj" word)
				'xdic-search-waei-dictionary
			      'xdic-search-eiwa-dictionary))
			word)
	  (setq buffer-read-only t)
	  (set-buffer-modified-p nil))
	(xdic-display-buffer xdic-buffer-start-point)
      (message "Can't find word, \"%s\"." word))))


(defun xdic-describe-region (start end &optional search-function)
  "Display the meaning of pattern."
  (interactive
   (list (region-beginning)
	 (region-end)
	 (if current-prefix-arg (xdic-select-search-function))))
  (xdic-describe-word (buffer-substring start end) search-function))


(defun xdic-describe-word-at-point ()
  "Display the meaning of word at point in Japanese."
  (interactive)
  (xdic-describe-word (or (xdic-word-at-point)
			  (xdic-read-from-minibuffer))))


;;; 次の項目に移動する関数
(defun xdic-forward-item ()
  "Move point to the next item."
  (interactive)
  (let ((o))
    (goto-char (xdic-next-overlay-change
		(if (setq o (car (xdic-overlays-at (point))))
		    (xdic-overlay-end o)
		  (point))))))


;;; 前の項目に移動する関数
(defun xdic-backward-item ()
  "Move point to the previous item."
  (interactive)
  (let ((o))
    (goto-char (xdic-previous-overlay-change
		(xdic-previous-overlay-change
		 (if (setq o (car (xdic-overlays-at (point))))
		     (xdic-overlay-start o)
		   (xdic-previous-overlay-change (xdic-previous-overlay-change (point)))))))))


(defun xdic-goto-point-min () "\
バッファの先頭に移動する関数"
  (interactive)
  (goto-char (point-min)))


(defun xdic-goto-point-max () "\
バッファの末尾に移動する関数"
  (interactive)
  (goto-char (point-max)))


(defun xdic-display-buffer (&optional start-point) "\
検索結果表示バッファを表示する関数"
  (let ((w1 (selected-window))
	(w2 (get-buffer-window xdic-buffer-name)))
    (if w2 (select-window w2)
      (setq w2 (select-window (if (one-window-p)
				  (split-window w1 (- (window-height) xdic-window-height))
				(next-window))))
      (set-window-buffer w2 xdic-buffer-name))
    (set-window-start w2 (or start-point (point)))
    (if xdic-disable-select-window (select-window w1))))


(defun xdic-other-window () "\
検索表示バッファから元のバッファに戻る関数"
  (interactive)
  (let ((w (selected-window)))
    (if (and (string= (buffer-name (window-buffer w))
		      xdic-buffer-name)
	     (one-window-p))
	(progn
	  (split-window w (- (window-height) xdic-window-height))
	  (set-window-buffer w (other-buffer)))
      (other-window -1))))


(defun xdic-close-window () "\
検索表示バッファを表示しているウインドウを消去する関数"
  (interactive)
  (let ((w (get-buffer-window xdic-buffer-name)))
    (if w
	(cond
	 ((= (window-height w) xdic-window-height)
	  (delete-window w))
	 (t
	  (set-window-buffer w (other-buffer))
	  (select-window (next-window)))
	 ))))


(defun xdic-exit () "\
検索結果表示バッファを削除する関数"
  (interactive)
  (xdic-close-window)
  (kill-buffer xdic-buffer-name)
  (mapcar 'xdic-close-dictionary xdic-eiwa-symbol-list)
  (mapcar 'xdic-close-dictionary xdic-waei-symbol-list)
  (setq xdic-eiwa-symbol-list nil
	xdic-waei-symbol-list nil))


;;; 辞書を閲覧する major-mode
(defun xdic-mode () "\
辞書を閲覧するメジャーモード

key             binding
---             -------

w               単語を検索する
SPC             スクロールアップ
b               スクロールダウン( BS / Delete キーも使えます )
n               次の項目
TAB             次の項目
p               前の項目
M-TAB           前の項目
o               辞書を閲覧しているウインドウから他のウインドウに移る
q               辞書を閲覧しているウインドウを消す
Q               Xdic を終了する
<               バッファの先頭に移動
>               バッファの終端に移動
?               ヘルプ表示
"
  (kill-all-local-variables)
  (make-local-variable 'fill-column)
  (setq major-mode 'xdic-mode
	mode-name   xdic-mode-name
	fill-column xdic-fill-column
	left-margin xdic-left-margin
	xdic-mode-map (make-keymap))
  ;; キーバインドの設定
  (define-key xdic-mode-map " " 'scroll-up)
  (define-key xdic-mode-map "b" 'scroll-down)
  (define-key xdic-mode-map [backspace] 'scroll-down)
  (define-key xdic-mode-map [delete] 'scroll-down)
  (define-key xdic-mode-map "\C-?" 'scroll-down)
  (define-key xdic-mode-map "n" 'xdic-forward-item)
  (define-key xdic-mode-map "\t" 'xdic-forward-item)
  (define-key xdic-mode-map "p" 'xdic-backward-item)
  (define-key xdic-mode-map "\M-\t" 'xdic-backward-item)
  (define-key xdic-mode-map "o" 'xdic-other-window)
  (define-key xdic-mode-map "q" 'xdic-close-window)
  (define-key xdic-mode-map "Q" 'xdic-exit)
  (define-key xdic-mode-map "w" 'xdic-describe-word)
  (define-key xdic-mode-map "<" 'xdic-goto-point-min)
  (define-key xdic-mode-map ">" 'xdic-goto-point-max)
  (define-key xdic-mode-map "?" 'describe-mode)
  (cond
   ((not xdic-disable-vi-key)
    (define-key xdic-mode-map "h" 'backward-char)
    (define-key xdic-mode-map "j" 'next-line)
    (define-key xdic-mode-map "k" 'previous-line)
    (define-key xdic-mode-map "l" 'forward-char)))
  (use-local-map xdic-mode-map)
  ;; 見出し語の face の設定
  (make-face 'xdic-face)
  (and (or (not (fboundp 'facep))
	   (facep xdic-face-style))
       (copy-face xdic-face-style 'xdic-face))
  (and window-system
       xdic-face-color
       (set-face-foreground 'xdic-face xdic-face-color))
  ;; それぞれの辞書を初期化する
  (or xdic-eiwa-symbol-list
      (setq xdic-eiwa-symbol-list
	    (delq nil (mapcar 'xdic-init-dictionary xdic-eiwa-dictionary-list))))
  (setq xdic-eiwa-symbol-list (delq nil (mapcar 'xdic-open-dictionary xdic-eiwa-symbol-list)))
  (or xdic-waei-symbol-list
      (setq xdic-waei-symbol-list
	    (delq nil (mapcar 'xdic-init-dictionary xdic-waei-dictionary-list))))
  (setq xdic-waei-symbol-list (delq nil (mapcar 'xdic-open-dictionary xdic-waei-symbol-list)))
  (run-hooks 'xdic-mode-hook))


;;; 1.6 との互換性を維持するための宣言
(defalias 'xdic:describe-word 'xdic-describe-word)
(defalias 'xdic:describe-word-at-point 'xdic-describe-word-at-point)




;;;----------------------------------------------------------------------
;;;		各種 Emacsen の違いを吸収する関数
;;;----------------------------------------------------------------------

(if (fboundp 'next-overlay-change)
    (defalias 'xdic-next-overlay-change 'next-overlay-change)
  ;; XEmacs の場合
  (defun xdic-next-overlay-change (pos) "\
Return the next position after POS where an extent starts or ends.
If there are no more extent boundaries after POS, return (point-max)."
    (catch 'found-next-extent
      (mapcar (function (lambda (ext)
			  (cond
			   ((> (extent-start-position ext) pos)
			    (throw 'found-next-extent (extent-start-position ext)))
			   ((> (extent-end-position ext) pos)
			    (throw 'found-next-extent (extent-end-position ext)))
			   )))
	      (extent-list))
      (point-max))))


(if (fboundp 'previous-overlay-change)
    (defalias 'xdic-previous-overlay-change 'previous-overlay-change)
  (if (fboundp 'extent-list)
      ;; XEmacs の場合
      (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an extent starts or ends.
If there are no more extent boundaries before POS, return (point-min)."
	(catch 'found-previous-extent
	  (mapcar (function (lambda (ext)
			      (cond
			       ((< (extent-end-position ext) pos)
				(throw 'found-previous-extent (extent-end-position ext)))
			       ((< (extent-start-position ext) pos)
				(throw 'found-previous-extent (extent-start-position ext)))
			       )))
		  (reverse (extent-list)))
	  (point-min)))
    ;; Emacs 19.34 以前の場合
    (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an overlay starts or ends.
If there are no more overlay boundaries before POS, return (point-min)."
      (if (> pos (point-max))
	  (error "Specified position is larger than point-max"))
      (save-excursion
	(let (next (prev (point-min)))
	  (while (> pos (setq next (xdic-next-overlay-change prev)))
	    (setq prev next))
	  prev)))))


(if (fboundp 'overlays-at)
    (defalias 'xdic-overlays-at 'overlays-at)
  (defun xdic-overlays-at (pos) "\
Return a list of the extents that contain position POS."
    (delq nil (mapcar (function (lambda (ext)
				  (and (<= (extent-start-position ext) pos)
				       (> (extent-end-position ext) pos)
				       ext)))
		      (extent-list)))))


(if (fboundp 'overlay-put)
    (defalias 'xdic-overlay-put 'overlay-put)
  (defalias 'xdic-overlay-put 'set-extent-property))


(if (fboundp 'make-overlay)
    (defalias 'xdic-make-overlay 'make-overlay)
  (defalias 'xdic-make-overlay 'make-extent))


(if (fboundp 'overlay-start)
    (defalias 'xdic-overlay-start 'overlay-start)
  (defalias 'xdic-overlay-start 'extent-start-position))


(if (fboundp 'overlay-end)
    (defalias 'xdic-overlay-end 'overlay-end)
  (defalias 'xdic-overlay-end 'extent-end-position))


(if (fboundp 'match-string)
    (defalias 'xdic-match-string 'match-string)
  ;; Introduced in Emacs 19.29.
  (defun xdic-match-string (num &optional string) "\
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING."
    (if (match-beginning num)
	(if string
	    (substring string (match-beginning num) (match-end num))
	  (buffer-substring (match-beginning num) (match-end num))))))


(defun xdic-split-string (string &optional separators) "\
Splits STRING into substrings where there are matches for SEPARATORS.
Each match for SEPARATORS is a splitting point.
The substrings between the splitting points are made into a list
which is returned.
If SEPARATORS is absent, it defaults to \"[ \\f\\t\\n\\r\\v]+\".

If there is match for SEPARATORS at the beginning of STRING, we do not
include a null substring for that.  Likewise, if there is a match
at the end of STRING, we don't include a null substring for that."
  (or separators (setq separators "[ \f\t\n\r\v]+"))
  (let (list (start 0))
    (while (string-match separators string start)
      (or (= start (match-beginning 0))
	  (setq list (cons (substring string start (match-beginning 0)) list)))
      (setq start (match-end 0)))
    (reverse (if (= start (length string)) list (cons (substring string start) list)))))


(defvar xdic-left-margin-ignored-by-fill-region (string-match "^19\\.28" emacs-version) "\
fill-region 関数が left-margin の設定を無視する場合は nil 以外を設定する")
(defun xdic-fill-region (start end) "\
Standarized fill-region.
fill-region の Emacs のバージョンによって異なる動作を標準化する関数"
  (save-match-data
    (if xdic-left-margin-ignored-by-fill-region
	;; Emacs-19.28 附属の fill-region は、left-margin を無視するので強制的に indent する
	(let ((fill-column (- fill-column xdic-left-margin)))
	  (fill-region start end)
	  (indent-region start (point) xdic-left-margin))
      (fill-region start end))
    (save-excursion			; 余分な空行を削除する
      (beginning-of-line)
      (if (looking-at "^[ \t]*$")
	  (delete-region (1- (point)) (match-end 0)))
      )))


(defun xdic-insert-file-contents (filename coding-system &optional visit beg end replace)
  (let ((coding-system-for-read coding-system)
	(file-coding-system-for-read coding-system))
    (insert-file-contents filename visit beg end replace)))


(defun xdic-call-process (program &optional infile buffer display coding-system &rest args)
  (let ((coding-system-for-read coding-system)
	(coding-system-for-write coding-system)
	(process-input-coding-system coding-system)
	(process-output-coding-system coding-system)
	(default-process-coding-system (cons coding-system coding-system)))
    (apply 'call-process program infile buffer display args)))


(defun xdic-start-process (name buffer coding-system program &rest args)
  (let ((proc (apply 'start-process name buffer program args)))
    (if (fboundp 'set-process-coding-system)
	(set-process-coding-system proc coding-system coding-system)
      (set-process-input-coding-system proc coding-system)
      (set-process-output-coding-system proc coding-system))
    proc))
